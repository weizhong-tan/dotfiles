export DOT_FILES=~/.dotfiles

# Aliases and functions
if [ -f "$DOT_FILES/common.sh" ]; then source "$DOT_FILES/common.sh"; fi

# Antidote setup.
{{- if eq .chezmoi.os "darwin" }}
source $(brew --prefix)/opt/antidote/share/antidote/antidote.zsh
{{- else if eq .chezmoi.os "linux" }}
source /home/wzt/.antidote/antidote.zsh
{{- end }}
antidote load

setopt sharehistory
bindkey '^[[Z' reverse-menu-complete
export COMPLETION_WAITING_DOTS="true";

zstyle :prompt:pure:git:stash show yes

autoload -Uz compinit
compinit
# On slow systems, checking the cached .zcompdump file to see if it must be
# regenerated adds a noticable delay to zsh startup.  This little hack restricts
# it to once a day.  It should be pasted into your own completion file.
#
# The globbing is a little complicated here:
# - '#q' is an explicit glob qualifier that makes globbing work within zsh's [[ ]] construct.
# - 'N' makes the glob pattern evaluate to nothing when it doesn't match (rather than throw a globbing error)
# - '.' matches "regular files"
# - 'mh+24' matches files (or directories or whatever) that are older than 24 hours.
if [[ -n ${ZDOTDIR:-${HOME}}/.zcompdump(#qN.mh+24) ]]; then
	compinit -d ~/.zcompdump;
else
	compinit -C;
fi;

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# Edit shell commands in vim
autoload -U edit-command-line
zle -N edit-command-line
bindkey '\C-x\C-e' edit-command-line

export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/11/bin

eval "$(starship init zsh)"

eval "$(zoxide init zsh --cmd j)"

{{ if eq .chezmoi.os "linux" -}}
FNM_PATH="/home/wzt/.local/share/fnm"
if [ -d "$FNM_PATH" ]; then
  export PATH="/home/wzt/.local/share/fnm:$PATH"
  eval "`fnm env --use-on-cd`"
fi
{{- end }}
eval "$(fnm env --use-on-cd)"

eval "$(direnv hook zsh)"

export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
export PUPPETEER_EXECUTABLE_PATH=/opt/homebrew/bin/chromium

function claude() {
  # first capture the real â€œclaudeâ€ binary
  local real_bin
  real_bin="$(whence -p claude)" || {
    echo "ðŸ’¥ could not locate upstream 'claude' binary" >&2
    return 1
  }
  # now shadow-remove this function so we can exec the real binary
  unset -f claude
  # set your env
  export BACKEND_ROOT="$HOME/dev/backend"
  export PATH="$PATH:$HOME/dev/backend/go/bin"
  export AWS_CONFIG_FILE="$HOME/dev/backend/.aws/config"
  export AWS_REGION=us-west-2
  export AWS_PROFILE=playground
  export CLAUDE_CODE_USE_BEDROCK=1
  # re-exec the real binary with all args
  exec "$real_bin" "$@"
}

# Interactively select and delete history entries with fzf
delete-history-fzf() {
    local entries=$(history | fzf --multi --tac --no-sort | awk '{print $1}')
    if [[ -n "$entries" ]]; then
        local count=0
        # Sort line numbers in reverse order to delete from bottom up
        # This prevents line number shifting during deletion
        echo "$entries" | sort -rn | while read line_number; do
            history -d "$line_number"
            sed -i.bak "${line_number}d" "$HISTFILE"
            ((count++))
        done
        fc -R
        echo "Deleted $count history entries"
    fi
}

